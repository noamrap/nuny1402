<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>驻住  - </title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* 注    砖拽 */
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to top, #4ca1af, #c4e0e5); /* 专 注 转专 */
        }

        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            pointer-events: none;
            color: white;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }

        #status {
            font-size: 24px;
            font-weight: 800;
        }

        #instructions {
            font-size: 14px;
            margin-top: 5px;
            opacity: 0.9;
        }

        /* 住 住 */
        #winScreen {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 10;
        }

        .heart-anim {
            font-size: 80px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* 拽 驻专  砖  */
        #divider {
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.1);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="status">0 专</div>
        <div id="instructions">
             砖: 爪 + WASD <br>
             : 注 爪 /砖  专专  转
        </div>
    </div>
    
    <div id="divider"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="winScreen">
        <div class="heart-anim"></div>
        <h1 style="color: #fff; text-shadow: 0 4px 10px rgba(0,0,0,0.5);"> 驻住!</h1>
        <button onclick="location.reload()" style="padding: 10px 20px; font-size: 18px; border-radius: 10px; border: none; cursor: pointer; background: white; color: #e25555; font-weight: bold;">砖拽 砖</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const winScreen = document.getElementById('winScreen');
        const statusDiv = document.getElementById('status');

        // --- 注转 转转 ---
        const player1Img = new Image();
        player1Img.src = "Screenshot_14.png"; // 转 砖

        const player2Img = new Image();
        player2Img.src = "Screenshot_15.png"; // 转 砖

        // --- 砖转 砖拽 ---
        let width, height;
        let gameActive = true;
        let progress = 0;
        const goal = 2000; // 专拽 拽爪转 转专 专 砖拽 注
        let obstacles = [];
        let particles = []; // 驻拽 砖 驻爪抓

        // 专转 砖拽
        const players = [
            { 
                id: 1,
                x: 0, y: 0, radius: 30, // 专 拽 -resize
                color: '#FF6B6B', img: player1Img,
                controls: { left: 'KeyA', right: 'KeyD' },
                vx: 0, targetX: null // 
            },
            { 
                id: 2,
                x: 0, y: 0, radius: 30,
                color: '#4ECDC4', img: player2Img,
                controls: { left: 'ArrowLeft', right: 'ArrowRight' },
                vx: 0, targetX: null
            }
        ];

        // --- 转  住 ---
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            // 拽 转转 住  住
            if (progress === 0) {
                players[0].x = width * 0.25;
                players[0].y = height - 100;
                players[1].x = width * 0.75;
                players[1].y = height - 100;
            }
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 砖 (拽转 + 注) ---
        const keys = {};
        window.addEventListener('keydown', e => keys[e.code] = true);
        window.addEventListener('keyup', e => keys[e.code] = false);

        // 砖转 注 (Multi-touch)
        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});
        canvas.addEventListener('touchend', handleTouchEnd, {passive: false});

        function handleTouch(e) {
            e.preventDefault(); // 注转 转 住
            for (let i = 0; i < e.touches.length; i++) {
                const touch = e.touches[i];
                //  注 爪 砖 -> 砖 砖拽 1, 爪  -> 砖拽 2
                if (touch.clientX < width / 2) {
                    players[0].targetX = touch.clientX;
                } else {
                    players[1].targetX = touch.clientX;
                }
            }
        }

        function handleTouchEnd(e) {
            // 砖爪注 注转, 驻住拽  专 住驻爪驻转
            // (驻砖专 砖专 转  null  注爪专 转注,  砖专 拽 专)
            //  砖专 拽 专  拽 转专
        }

        // --- 拽 ---
        function update() {
            if (!gameActive) {
                if (progress >= goal) animateKiss();
                return;
            }

            // 注 转拽转 拽砖
            progress += 2;
            const percentage = Math.floor((progress / goal) * 100);
            statusDiv.innerText = `转拽转: ${percentage}%`;

            if (progress >= goal) endGame();

            // 转注转 砖拽
            players.forEach((p, index) => {
                // 拽转
                if (keys[p.controls.left]) p.x -= 7;
                if (keys[p.controls.right]) p.x += 7;

                // 注 (Smooth movement)
                if (p.targetX !== null) {
                    // 转 拽 注专 爪注
                    p.x += (p.targetX - p.x) * 0.2;
                }

                // 转 专
                // 砖拽 1  爪 砖, 砖拽 2 爪  (驻爪,  转转 驻砖  注 转 住)
                if (p.x < p.radius) p.x = p.radius;
                if (p.x > width - p.radius) p.x = width - p.radius;
                
                //  砖 专  ( 驻注)
                if (p.y < height - 100) {
                    p.y += 2;
                } else {
                    p.y = height - 100;
                }
            });

            //  砖
            const difficulty = 0.05 + (progress / goal) * 0.1; //  拽砖 转专
            if (Math.random() < difficulty) {
                const size = 30 + Math.random() * 40;
                obstacles.push({
                    x: Math.random() * width,
                    y: -size,
                    size: size,
                    speed: 4 + Math.random() * 5 + (progress/500), //  专 转专
                    rotation: Math.random() * Math.PI,
                    rotSpeed: (Math.random() - 0.5) * 0.2
                });
            }

            // 注 砖 拽转 转砖转
            obstacles.forEach((obs, i) => {
                obs.y += obs.speed;
                obs.rotation += obs.rotSpeed;

                // 拽  爪 住
                if (obs.y > height + obs.size) {
                    obstacles.splice(i, 1);
                    return;
                }

                // 转砖转 (注  注)
                players.forEach(p => {
                    const dx = p.x - obs.x;
                    const dy = p.y - obs.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);

                    if (dist < p.radius + obs.size/2) {
                        // 驻注!
                        createParticles(p.x, p.y, p.color);
                        p.y += 150; // 注砖: 注祝 专 砖注转转
                        if (p.y > height) p.y = height; //  爪转 住
                        
                        // 专拽 拽 砖 砖 砖 驻注 砖 
                        obs.y += 50; 
                    }
                });
            });

            // 注 拽拽
            particles.forEach((part, i) => {
                part.x += part.vx;
                part.y += part.vy;
                part.life--;
                if(part.life <= 0) particles.splice(i, 1);
            });
        }

        function createParticles(x, y, color) {
            for(let i=0; i<10; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 20,
                    color: color
                });
            }
        }

        // --- 爪专 ---
        function draw() {
            ctx.clearRect(0, 0, width, height);

            // 爪专 拽 专 ( 爪/)
            ctx.beginPath();
            ctx.moveTo(players[0].x, players[0].y);
            ctx.quadraticCurveTo(width/2, height - 50, players[1].x, players[1].y);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 10]); // 拽 拽拽
            ctx.stroke();
            ctx.setLineDash([]);

            // 爪专 砖
            obstacles.forEach(obs => {
                ctx.save();
                ctx.translate(obs.x, obs.y);
                ctx.rotate(obs.rotation);
                ctx.fillStyle = '#4a4a4a';
                // 爪专 爪专 拽爪转 转专 注转 住转 注 ( 住注)
                ctx.beginPath();
                ctx.moveTo(-obs.size/2, -obs.size/2);
                ctx.lineTo(obs.size/2, -obs.size/2);
                ctx.lineTo(0, obs.size/2);
                ctx.fill();
                ctx.restore();
            });

            // 爪专 砖拽
            players.forEach(p => {
                ctx.save();
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.closePath();
                ctx.clip(); // 转 转 注

                try {
                    ctx.drawImage(p.img, p.x - p.radius, p.y - p.radius, p.radius*2, p.radius*2);
                } catch (e) {
                    ctx.fillStyle = p.color;
                    ctx.fill();
                }
                ctx.restore();

                // 住专转 专转
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#fff';
                ctx.stroke();
            });

            // 爪专 拽拽
            particles.forEach(part => {
                ctx.fillStyle = part.color;
                ctx.fillRect(part.x, part.y, 4, 4);
            });
        }

        // --- 住 ---
        function endGame() {
            gameActive = false;
            statusDiv.style.display = 'none';
            document.getElementById('divider').style.display = 'none';
            winScreen.style.display = 'block';
        }

        function animateKiss() {
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 转拽专转 专
            players[0].x += (centerX - 40 - players[0].x) * 0.05;
            players[0].y += (centerY - players[0].y) * 0.05;
            
            players[1].x += (centerX + 40 - players[1].x) * 0.05;
            players[1].y += (centerY - players[1].y) * 0.05;
        }

        // 转 砖拽
        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        // 转
        loop();

    </script>
</body>
</html>
